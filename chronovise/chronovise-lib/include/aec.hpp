/*
 *  chronovise - Copyright 2018 Politecnico di Milano
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file aec.hpp
 * @author Check commit authors
 * @brief File containing the AbstractExecutionContext class
 */

#ifndef AEC_HPP_
#define AEC_HPP_

#include "evt/evtapproach.hpp"
#include "evt/pwcet.hpp"
#include "fixer.hpp"
#include "global.hpp"
#include "input/generator.hpp"
#include "measures_pool.hpp"
#include "safety.hpp"
#include "statistical/test.hpp"
#include "statistical/estimator.hpp"
#include "utility/utility_hmi.hpp"

#include <list>
#include <memory>
#include <string>

namespace chronovise {

/**
 * Represents the list of available merger type of the EVT process. It is basically
 * composed of two possible strategies: trace-merging or envelope-merging. The
 * former merge all the measurements from different input dataset into one single
 * dataset to be analyzed. The latter computes pWCET for each input and provides
 * a merge of pWCET at the end. 
 */
typedef enum class merger_type_e {
    UNKNOWN,     /** Internal representation, should not be used */
    TRACE_MERGE, /** Trace-merging technique */
    ENVELOPE     /** Envelope-merging technique */
} merger_type_t;


/**
 * The abstract class to be extended by the application. It is often shorten in the
 * documentation with AEC acronym (AbstractExecutionContext). The run() method contains
 * the logic of the pWCET analysis.
 */
template <typename T_INPUT=unsigned long, typename T_TIME=unsigned long>
class AbstractExecutionContext {

public:

    /**
     * The constructor of the AEC class. If the verbosity is enabled, it prints the
     * welcome message.
     */
    explicit AbstractExecutionContext() {
        VERB(utility::print_welcome_message());
    }

    /**
     * The destructor of the AEC class is the default one.
     */
    virtual ~AbstractExecutionContext() = default;

    /**
     * The list of possible exit status codes. It is used by AEC-implemented methods
     * and must be used by children classes.
     */
    typedef enum {

        // Normal statuses
        AEC_OK = 0,      /** `Successful` or `completed` meaning */
        AEC_CONTINUE,    /** Instructs the framework to continue an action */
        AEC_SLOTH,       /** Instructs the framework to decide itself something*/

        // Error statuses
        AEC_GENERIC_ERROR,    /** Generic error code */ 

        AEC_INPUT_ERROR,  /** Something wrong with input values */

    } exit_code_t;


    /**
     * The method called at the startup of the program. This method is called only
     * once time and its goal should be to set up the AEC class, i.e. setting the
     * evt approach, evt tests, etc.
     */
    virtual exit_code_t onSetup() = 0;

    /**
     * The method called each time a new input is generated by the input generator.
     * The user has to return AEC_CONTINUE/AEC_OK in order to continue or stop the
     * execution. If this method returns AEC_SLOTH the input test representativity
     * is used to decide if continue or not.
     */
    virtual exit_code_t onConfigure() = 0;

    /**
     * The main method used to acquire the sample timing. The timing can be computed
     * on the fly or readed from some source.
     */
    virtual exit_code_t onRun() = 0;

    /**
     * This function is executed every time after the onRun() and it should decide
     * if the execution should continue or stop. Similar to onConfigure() it may
     * return AEC_CONTINUE, AEC_OK or AEC_SLOTH. If the result is to continue, the
     * onRun() is called, otherwise the next function would be the onConfigure().
     */
    virtual exit_code_t onMonitor() = 0;

    /**
     * The last function called for cleanup at the end of all iterations. It is
     * called only one time per run.
     */
    virtual exit_code_t onRelease() = 0;

    /**
     * The list of possible exit status codes. It is used by AEC-implemented methods
     * and must be used by children classes. If something fails it may throw exception
     * or abort the program.
     * @throws std::runtime_error in case of some failures or abort the program
     * immediately
     */
    void run();

    /**
     * It prints to stderr a legend for the symbols printed by the AEC run() method.
     * @note It does NOT depend on the macro `VERBOSITY_NONE`.
     */
    void print_legend() const noexcept;

    /**
     * Print the distribution summary. It must be called at the end of execution,
     * otherwise no output is provided.
     * @note For some merging technique like trace-merge, it provides only a single
     * value. 
     * @note It does NOT depend on the macro `VERBOSITY_NONE`.
     */
    void print_distributions_summary() const noexcept;

    /**
     * Print the configuration information of AEC such as tests, evt approach, etc.
     * @note It does NOT depend on the macro `VERBOSITY_NONE`.
     */    
    void print_configuration_info() const noexcept;

    /**
     * It prints the information on computer Worst-Case Observed Time. No analysis
     * is performed to carry out this value, just the maximum time per input.
     * @note It does NOT depend on the macro `VERBOSITY_NONE`.
     */
    void print_wcots() const noexcept;

    /**
     * Print the information about the EVT approach process such as number of samples
     * acquired and remained after BM/PoT.
     * @note It does NOT depend on the macro `VERBOSITY_NONE`.
     */
    void print_evt_info() const noexcept;

    /**
     * Given a probability, returns the global (i.e. the largest) worst-case execution time
     */
    T_TIME get_pwcet_wcet(double probability) const noexcept;

    /**
     * Given a worst-case-execution time, returns the global (i.e. the smallest) probability
     */
    double get_pwcet_probability(T_TIME wcet) const noexcept;

    /**
     * Getter for the list of acquired samples
     */
    const MeasuresPool<T_INPUT, T_TIME> & get_measures() const noexcept {
        return this->measures;
    }

    /**
     * Getter for the list of Worst-Case Observed Times
     */
    const MeasuresPool<T_INPUT, T_TIME> & get_wcots() const noexcept {
        return this->wcots;
    }

    /**
     * Getter for the list of estimated distributions
     */
    const std::list<std::shared_ptr<Distribution>> & get_estimated_distributions() const noexcept {
        return this->ev_dist_estimated;
    }

    /**
     * Getter for the Safety object associated to this AEC
     */
    inline const Safety& get_safety_info() const noexcept {
        return this->safety;
    }


protected:

    /**
     * A typedef for convenience to shorten generic statistical test pointer.
     */
    typedef std::shared_ptr<StatisticalTest<T_INPUT,T_TIME>> test_ptr_t;

    /**
     * A typedef for convenience to shorten post-EVT statistical test pointer.
     */
    typedef std::shared_ptr<StatisticalTest_AfterEVT<T_INPUT, T_TIME>> test_aft_ptr_t;

    /**
     * Setter for the input generator source. This is mandatory before call run().
     */
    inline void set_input_source(std::unique_ptr<InputGenerator<T_INPUT>> ig) noexcept {
        this->input_gen = std::move(ig);
    }

    /**
     * Setter for the merging technique to use. This is mandatory before call run().
     */
    inline void set_merging_technique(merger_type_t type) noexcept {
        this->merger_tech = type;
    }

    /**
     * Configure the approach to use to split and/or select samples.
     * @param evt_approach The pointer to the class performing the splitting/selecting approach
     * @param samples_test_reserve The percentage of samples to be reserved for testing expressed
     *      as a number from 0 to 1. Values near 0 reduces the test power. Values near 1 reduces
     *       the estimation precision (and it may consequently lead to a test failure).
     */
    void set_evt_approach(std::unique_ptr<EVTApproach<T_INPUT, T_TIME>> evt_approach,
                    float samples_test_reserve=0.) noexcept;

    /**
     * Set the EVT estimator to use. This is mandatory before call run().
     */
    inline void set_evt_estimator(std::unique_ptr<Estimator<T_INPUT, T_TIME>> est) noexcept {
        this->evt_estimator = std::move(est);
    }

    /**
     * Add a new sample to the MeasuresPool of this AEC for the current input. This method should be
     * called inside onRun() only.
     */
    inline void add_sample(T_TIME value) noexcept {
        this->measures.push(current_input, value);
    }

//    TODO    
//    inline void add_input_transformer() noexcept;

    /**
     * Add a new input representativity test.
     */
    inline void add_input_representativity_test(test_ptr_t st) noexcept {
        this->representativity_tests.push_back(st);
    }

    /**
     * Add a new test executed on post EVT-approach samples (e.g. on the output samples of BM)
     */
    inline void add_post_approach_test(test_ptr_t st) noexcept {
        this->post_run_tests.push_back(std::move(st));
    }

    /**
     * Add a new test executed on pre EVT-approach samples (e.g. on the output samples of BM)
     */
    inline void add_sample_test(test_ptr_t st) noexcept {
        this->sample_tests.push_back(std::move(st));
    }

    /**
     * Add a new post-EVT test, typically a goodness-of-fit test
     */
    inline void add_post_evt_test(test_aft_ptr_t st) noexcept {
        this->post_evt_tests.push_back(std::move(st));
    }

    /**
     * Return the current input value
     */
    inline const T_INPUT& get_current_input_value() const noexcept {
        return this->current_input;
    }

    /**
     * Return the number of the current input iteration (outer loop).
     * @note The first iteration has number '0'
     */
    inline unsigned long get_input_iteration() const noexcept {
        return input_iteration;
    }

    /**
     * Return the number of the current iteration inside the current input (inner loop).
     * @note The first iteration has number '0'
     */
    inline unsigned long get_iteration() const noexcept {
        return iteration;
    }

    /**
     * Ask to the framework for a reliability requirement
     * @warning Experimental feature
     */
    inline void set_reliability_requirement(double req) noexcept {
        safety.set_reliability_requirement(req);
    }

private:

    /* *** PRIVATE TYPES *** */
    typedef std::list<test_ptr_t> list_of_test_t;
    typedef std::list<test_aft_ptr_t> list_of_aft_test_t;


    /* *** CONSTANT ATTRIBUTES *** */
    static constexpr char hmi_10_iteration      = '.';
    static constexpr char hmi_more_sample       = '>';
    static constexpr char hmi_reject_sample     = '$';
    static constexpr char hmi_fail_estimator    = '#';
    static constexpr char hmi_reject_evt        = 'X';
    static constexpr char hmi_success           = '+';
    static constexpr char hmi_no_enough_samples = 'N';



    /* *** ATTRIBUTES - CONFIGURATION *** */
    float samples_test_reserve = 0; /** 0-1: ratio of samples reserved for testing */

    merger_type_t merger_tech = merger_type_t::UNKNOWN;

    std::unique_ptr<InputGenerator<T_INPUT>> input_gen;
    std::unique_ptr<EVTApproach<T_INPUT, T_TIME>> evt_approach;
    std::unique_ptr<Estimator<T_INPUT, T_TIME>> evt_estimator;

    list_of_test_t representativity_tests;
    list_of_test_t sample_tests;
    list_of_test_t post_run_tests;
    list_of_aft_test_t post_evt_tests;

    /* *** ATTRIBUTES - RUNTIME *** */

    unsigned long input_iteration  = 0;
    unsigned long iteration        = 0;
    unsigned long min_nr_iterations_train = 0;
    unsigned long min_nr_iterations_tests = 0;
    unsigned long min_nr_iterations_total = 0;

    T_INPUT current_input;

    MeasuresPool<T_INPUT, T_TIME> measures;
    MeasuresPool<T_INPUT, T_TIME> wcots;
    std::list<std::shared_ptr<Distribution>> ev_dist_estimated;

    Safety safety;

    /* *** METHODS *** */

    [[noreturn]] inline void print_error(const std::string &s) const {
        throw std::runtime_error("An error occurred, error description follows: "+s);
    }

    void external_cycle();

    void internal_cycle();

    aec_status_t execute_analysis();

    void check_preconditions() const noexcept;

    void set_min_iterations() noexcept;



};

} // namespace chronovise
#endif
